#!/usr/bin/env bash
# Check for available updates to flake inputs and custom packages
# Analogous to 'dnf check-update' — shows what's available without changing anything
#
# Usage:
#   check-updates [OPTIONS] [NAME...]
#
# Options:
#   --all           Include transitive (indirect) flake dependencies
#   --inputs-only   Only check flake inputs, skip custom packages
#   --pkgs-only     Only check custom packages, skip flake inputs
#
# If no names specified, checks all direct flake inputs and custom packages.
# Examples:
#   check-updates                  # check everything
#   check-updates nixpkgs          # check only nixpkgs input
#   check-updates --all            # include transitive deps
#   check-updates --pkgs-only      # only check pkgs/ packages

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=scripts/lib/colors
source "${SCRIPT_DIR}/lib/colors"

FLAKE_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
LOCK_FILE="${FLAKE_DIR}/flake.lock"

# Parse arguments
SHOW_ALL=false
INPUTS_ONLY=false
PKGS_ONLY=false
FILTER_NAMES=()

while [[ $# -gt 0 ]]; do
  case $1 in
    --all)
      SHOW_ALL=true
      shift
      ;;
    --inputs-only)
      INPUTS_ONLY=true
      shift
      ;;
    --pkgs-only)
      PKGS_ONLY=true
      shift
      ;;
    --help | -h)
      echo "Usage: check-updates [OPTIONS] [NAME...]"
      echo ""
      echo "Check for available updates to flake inputs and custom packages."
      echo ""
      echo "Options:"
      echo "  --all           Include transitive (indirect) flake dependencies"
      echo "  --inputs-only   Only check flake inputs, skip custom packages"
      echo "  --pkgs-only     Only check custom packages, skip flake inputs"
      echo "  -h              Show this help"
      echo ""
      echo "If no names specified, checks all direct flake inputs and custom packages."
      exit 0
      ;;
    *)
      FILTER_NAMES+=("$1")
      shift
      ;;
  esac
done

# Check dependencies
for cmd in jq gh; do
  if ! command -v "$cmd" &>/dev/null; then
    error_and_exit "$cmd is required but not installed"
  fi
done

if [[ ! -f "$LOCK_FILE" ]]; then
  error_and_exit "No flake.lock found at $LOCK_FILE"
fi

# Get direct input names from the root node
mapfile -t DIRECT_INPUTS < <(jq -r '.nodes.root.inputs | to_entries[] | .value' "$LOCK_FILE")

# Get all GitHub-hosted inputs from flake.lock
mapfile -t ALL_INPUTS < <(jq -r '
  .nodes | to_entries[] |
  select(.key != "root") |
  select(.value.locked != null) |
  select(.value.locked.type == "github") |
  .key
' "$LOCK_FILE")

is_direct_input() {
  local name="$1"
  for di in "${DIRECT_INPUTS[@]}"; do
    if [[ "$di" == "$name" ]]; then
      return 0
    fi
  done
  return 1
}

matches_filter() {
  local name="$1"
  if [[ ${#FILTER_NAMES[@]} -eq 0 ]]; then
    return 0
  fi
  for fi_name in "${FILTER_NAMES[@]}"; do
    if [[ "$fi_name" == "$name" ]]; then
      return 0
    fi
  done
  return 1
}

# Extract a nix attribute value: extract_nix_attr "owner" < file.nix
extract_nix_attr() {
  local attr="$1"
  local file="$2"
  grep -oP "${attr}\\s*=\\s*\"\\K[^\"]+" "$file" | head -1
}

# Format epoch timestamp portably (GNU date -d vs BSD date -r)
format_epoch() {
  local epoch="$1"
  date -d "@${epoch}" '+%Y-%m-%d' 2>/dev/null ||
    date -r "${epoch}" '+%Y-%m-%d' 2>/dev/null ||
    echo "unknown"
}

HAS_UPDATES=false
CHECKED=0

# --- Flake inputs ---
if [[ "$PKGS_ONLY" != "true" ]]; then

info "Flake inputs"
echo ""

for INPUT in "${ALL_INPUTS[@]}"; do
  # Filter: skip transitive deps unless --all or explicitly named
  if [[ ${#FILTER_NAMES[@]} -eq 0 ]] && [[ "$SHOW_ALL" != "true" ]]; then
    if ! is_direct_input "$INPUT"; then
      continue
    fi
  fi

  # Filter: skip if specific inputs were requested and this isn't one
  if ! matches_filter "$INPUT"; then
    continue
  fi

  OWNER=$(jq -r ".nodes.\"${INPUT}\".locked.owner" "$LOCK_FILE")
  REPO=$(jq -r ".nodes.\"${INPUT}\".locked.repo" "$LOCK_FILE")
  LOCKED_REV=$(jq -r ".nodes.\"${INPUT}\".locked.rev" "$LOCK_FILE")
  LOCKED_EPOCH=$(jq -r ".nodes.\"${INPUT}\".locked.lastModified" "$LOCK_FILE")
  REF=$(jq -r ".nodes.\"${INPUT}\".original.ref // empty" "$LOCK_FILE")

  LABEL="${INPUT} (${OWNER}/${REPO})"
  if [[ -n "$REF" ]]; then
    LABEL="${LABEL} [${REF}]"
  fi
  step "$LABEL"

  # Query GitHub for the latest commit on the tracked ref
  TARGET_REF="${REF:-HEAD}"
  LATEST_JSON=$(gh api "repos/${OWNER}/${REPO}/commits/${TARGET_REF}" \
    --jq '{ rev: .sha, date: .commit.committer.date }' 2>/dev/null || echo "")

  if [[ -z "$LATEST_JSON" ]]; then
    warn "  Could not fetch latest commit (API error or rate limit)"
    echo ""
    continue
  fi

  LATEST_REV=$(echo "$LATEST_JSON" | jq -r '.rev')
  LATEST_DATE=$(echo "$LATEST_JSON" | jq -r '.date')
  LOCKED_DATE_FMT=$(format_epoch "$LOCKED_EPOCH")

  if [[ "$LOCKED_REV" == "$LATEST_REV" ]]; then
    info "  Up to date (${LOCKED_REV:0:12}, ${LOCKED_DATE_FMT})"
  else
    HAS_UPDATES=true
    echo -e "  ${YELLOW}Update available${NC}"
    echo "    Locked:  ${LOCKED_REV:0:12} (${LOCKED_DATE_FMT})"
    echo "    Latest:  ${LATEST_REV:0:12} (${LATEST_DATE})"

    # Try to get the number of commits between locked and latest
    BEHIND=$(gh api "repos/${OWNER}/${REPO}/compare/${LOCKED_REV:0:12}...${LATEST_REV:0:12}" \
      --jq '.ahead_by' 2>/dev/null || echo "")
    if [[ -n "$BEHIND" && "$BEHIND" != "null" ]]; then
      echo "    Behind:  ${BEHIND} commit(s)"
    fi

    echo "    Compare: https://github.com/${OWNER}/${REPO}/compare/${LOCKED_REV:0:12}...${LATEST_REV:0:12}"
  fi
  echo ""
  CHECKED=$((CHECKED + 1))
done

fi # end PKGS_ONLY guard

# --- Custom packages in pkgs/ ---
if [[ "$INPUTS_ONLY" != "true" ]]; then

PKGS_DIR="${FLAKE_DIR}/pkgs"

if [[ -d "$PKGS_DIR" ]]; then
  info "Custom packages (pkgs/)"
  echo ""

  # Find all .nix files that use fetchFromGitHub
  while IFS= read -r NIX_FILE; do
    PKG_NAME=$(basename "$(dirname "$NIX_FILE")")
    # For files not in a subdirectory (unlikely), use filename
    if [[ "$PKG_NAME" == "pkgs" ]]; then
      PKG_NAME=$(basename "$NIX_FILE" .nix)
    fi

    if ! matches_filter "$PKG_NAME"; then
      continue
    fi

    OWNER=$(extract_nix_attr "owner" "$NIX_FILE")
    REPO=$(extract_nix_attr "repo" "$NIX_FILE")
    REV=$(extract_nix_attr "rev" "$NIX_FILE")

    if [[ -z "$OWNER" || -z "$REPO" || -z "$REV" ]]; then
      continue
    fi

    VERSION=$(extract_nix_attr "version" "$NIX_FILE")
    step "${PKG_NAME} (${OWNER}/${REPO}) [${VERSION:-unknown}]"

    # Determine the ref to check: if rev looks like a branch name, use it; otherwise check default branch
    if [[ "$REV" =~ ^[0-9a-f]{7,40}$ ]]; then
      # Rev is a commit hash — check the default branch for newer commits
      TARGET_REF="HEAD"
    else
      # Rev is a branch/tag name (e.g., "main")
      TARGET_REF="$REV"
    fi

    LATEST_JSON=$(gh api "repos/${OWNER}/${REPO}/commits/${TARGET_REF}" \
      --jq '{ rev: .sha, date: .commit.committer.date }' 2>/dev/null || echo "")

    if [[ -z "$LATEST_JSON" ]]; then
      warn "  Could not fetch latest commit (API error or rate limit)"
      echo ""
      continue
    fi

    LATEST_REV=$(echo "$LATEST_JSON" | jq -r '.rev')
    LATEST_DATE=$(echo "$LATEST_JSON" | jq -r '.date')

    # For branch-pinned packages, the rev in the nix file is the branch name, not a hash.
    # Compare the locked hash (from sha256/hash attr) indirectly — if latest commit differs, there may be updates.
    if [[ "$REV" =~ ^[0-9a-f]{7,40}$ ]]; then
      # Commit-pinned: direct comparison
      if [[ "${LATEST_REV}" == "${REV}"* || "${REV}" == "${LATEST_REV}"* ]]; then
        info "  Up to date (${REV:0:12})"
      else
        HAS_UPDATES=true
        echo -e "  ${YELLOW}Update available${NC}"
        echo "    Pinned:  ${REV:0:12}"
        echo "    Latest:  ${LATEST_REV:0:12} (${LATEST_DATE})"

        BEHIND=$(gh api "repos/${OWNER}/${REPO}/compare/${REV:0:12}...${LATEST_REV:0:12}" \
          --jq '.ahead_by' 2>/dev/null || echo "")
        if [[ -n "$BEHIND" && "$BEHIND" != "null" ]]; then
          echo "    Behind:  ${BEHIND} commit(s)"
        fi

        echo "    Compare: https://github.com/${OWNER}/${REPO}/compare/${REV:0:12}...${LATEST_REV:0:12}"
        echo "    File:    ${NIX_FILE#"${FLAKE_DIR}/"}"
      fi
    else
      # Branch-pinned: can't compare hashes, just show latest commit info
      echo -e "  ${YELLOW}Pinned to branch '${REV}' — cannot diff without rebuilding${NC}"
      echo "    Latest commit: ${LATEST_REV:0:12} (${LATEST_DATE})"
      echo "    File:          ${NIX_FILE#"${FLAKE_DIR}/"}"
    fi
    echo ""
    CHECKED=$((CHECKED + 1))
  done < <(grep -rl "fetchFromGitHub" "${PKGS_DIR}" --include="*.nix")

  # Find all .nix files that use fetchPypi
  while IFS= read -r NIX_FILE; do
    PKG_NAME=$(extract_nix_attr "pname" "$NIX_FILE")
    if [[ -z "$PKG_NAME" ]]; then
      continue
    fi

    if ! matches_filter "$PKG_NAME"; then
      continue
    fi

    CURRENT_VERSION=$(extract_nix_attr "version" "$NIX_FILE")
    if [[ -z "$CURRENT_VERSION" ]]; then
      continue
    fi

    step "${PKG_NAME} (PyPI) [${CURRENT_VERSION}]"

    LATEST_VERSION=$(curl -sf "https://pypi.org/pypi/${PKG_NAME}/json" | jq -r '.info.version' 2>/dev/null || echo "")

    if [[ -z "$LATEST_VERSION" ]]; then
      warn "  Could not fetch from PyPI"
      echo ""
      continue
    fi

    if [[ "$CURRENT_VERSION" == "$LATEST_VERSION" ]]; then
      info "  Up to date (${CURRENT_VERSION})"
    else
      HAS_UPDATES=true
      echo -e "  ${YELLOW}Update available${NC}"
      echo "    Pinned:  ${CURRENT_VERSION}"
      echo "    Latest:  ${LATEST_VERSION}"
      echo "    PyPI:    https://pypi.org/project/${PKG_NAME}/"
      echo "    File:    ${NIX_FILE#"${FLAKE_DIR}/"}"
    fi
    echo ""
    CHECKED=$((CHECKED + 1))
  done < <(grep -rl "fetchPypi" "${PKGS_DIR}" --include="*.nix")
fi

fi # end INPUTS_ONLY guard

if [[ $CHECKED -eq 0 ]]; then
  warn "No items matched"
  exit 1
fi

# Summary
echo "---"
if [[ "$HAS_UPDATES" == "true" ]]; then
  info "Updates available. To apply:"
  echo "  nix flake update              # update flake inputs"
  echo "  nix flake update <input>      # update specific flake input"
  echo "  # For custom packages, update rev/version/hash in the .nix file"
else
  success "Everything is up to date"
fi
